Rest Assured is a Java-based library used for testing RESTful APIs.
It provides a domain-specific language (DSL) for writing readable and maintainable API tests.
It eliminates boilerplate code by handling request building, sending, and response parsing easily.

Simple and human-readable syntax.
Built-in support for BDD (given(), when(), then()).
Supports JSON & XML validation.
Easy integration with TestNG/JUnit.
Supports OAuth, Basic, Digest, Form authentication.

** Rest Assured internally uses Apache HTTP Client but can also work with other HTTP clients if configured.

given()
    .baseUri("https://api.example.com")
.when()
    .get("/users/1")
.then()
    .statusCode(200)
    .body("name", equalTo("John"));

given()
    .queryParam("page", 2)
    .queryParam("size", 20)
.when()
    .get("/users")
.then()
    .statusCode(200);

given()
    .header("Content-Type", "application/json")
    .header("Authorization", "Bearer token")

    String requestBody = "{ \"name\": \"John\", \"age\": 30 }";
     given()
        .header("Content-Type", "application/json")
        .body(requestBody)
    .when()
        .post("/users")
    .then()
        .statusCode(201);

String name = response.jsonPath().getString("name");


validate response time in Rest Assured?
given()
    .get("/users/1")
.then()
    .time(lessThan(2000L));

Authentication in Rest Assured :
Basic Auth: given().auth().basic("username", "password");
Bearer Token: given().header("Authorization", "Bearer token");
OAuth2 : given().auth().oauth2("access_token");

difference between path() and jsonPath()?
path() ‚Üí Direct extraction from response (works for JSON & XML).
jsonPath() ‚Üí Parses JSON and allows querying deeply nested fields.

How do you structure a Rest Assured framework in real projects?
Base class ‚Üí set baseURI, authentication, common headers.
Utils layer ‚Üí reusable methods for requests, payload builders.
Tests layer ‚Üí organized TestNG/JUnit classes.
Data layer ‚Üí JSON payloads, schema files, external test data.
Reports ‚Üí integrate with Extent, Allure, or TestNG reports.

How do you handle dynamic payloads in Rest Assured?
JSONObject request = new JSONObject();
request.put("name", "John");
request.put("age", 30);

given()
    .header("Content-Type", "application/json")
    .body(request.toString())
.when()
    .post("/users")
.then()
    .statusCode(201);

How do you run Rest Assured tests in parallel?
Use TestNG parallel execution (parallel="classes" or "methods") in testng.xml.
Make sure to avoid shared state (thread-safe utilities).

How do you log request and response in Rest Assured?
given()
    .log().all()
.when()
    .get("/users/1")
.then()
    .log().all();

 What are some best practices for API testing with Rest Assured?
 Keep base URI & authentication in a central config.
 Use POJOs for request/response mapping (instead of raw strings).
 Use JSON schema validation for contract testing.
 Separate test logic from test data.
 Integrate with reporting tools.
 Use mocking/stubbing (e.g., WireMock) for dependent services.



 RestAssured.baseURI is a static variable. Once set, all Rest Assured requests that don‚Äôt explicitly specify a full URL
 will automatically prepend this base URI.
 Then we can use given() like below.
                             .when()
                             .get(endpoint)   // endpoint = "/users/2"
                             .then()
                             .extract()
                             .response();

 Rest Assured internally constructs the full URL as:  https://reqres.in/api/users/2.  Rest Assured automatically
 combines baseURI + endpoint.
 You don‚Äôt need to repeat the domain in every test.

 Overriding Base URI  :
 If you ever want to override baseURI for a specific request:
 given()
     .baseUri("https://another-api.com")
     .get("/data");
This overrides the global RestAssured.baseURI just for that request.

If we want, we can update RestUtils to read baseURI from a config.properties file so the framework becomes fully
configurable for multiple environments (dev/staging/prod).
This is usually preferred in professional SDET frameworks.



Why testng.xml is Needed?
testng.xml is TestNG‚Äôs configuration file. It tells TestNG which tests to run, how to run them, and in what order.
While you can run individual test classes directly, testng.xml gives much more control and flexibility.
Grouping & Organization : You can define multiple <test> blocks, each containing a group of classes.
<suite name="API Suite">
    <test name="User APIs">
        <classes>
            <class name="tests.UserTests"/>
        </classes>
    </test>
    <test name="Product APIs">
        <classes>
            <class name="tests.ProductTests"/>
        </classes>
    </test>
</suite>
This allows you to organize tests logically and run specific groups easily.
Parallel Execution :  You can configure parallel test execution in testng.xml:
<suite name="API Suite" parallel="tests" thread-count="2">
This is not possible if you just run classes individually via your IDE. Helps speed up execution, especially for
API tests.
Listeners & Reporters : You can attach listeners (ITestListener, ISuiteListener) and reporters globally:
<listeners>
    <listener class-name="utils.TestRailListener"/>
</listeners>
All tests in the suite automatically use the listener; no need to add it to every class.
Cross-Environment Testing / Parameters : You can pass parameters or environment variables to tests:
<parameter name="baseUrl" value="https://dev-api.com"/>
<parameter name="env" value="staging"/>
Tests can read these via @Parameters in TestNG.
This makes the framework configurable without changing code.
Execution Control :
Control order of test execution using depends-on-method or suite/test order.
Decide which tests to include or exclude using <packages> or <classes>.


When given like in testng.xml file like below
parallel="tests" thread-count="2"
  --> Runs multiple <test> blocks in parallel.
  Each <test> block can contain multiple classes.
  Useful for faster execution of large API suites.

When given like in testng.xml file like below
<parameter name="baseUrl" value="https://reqres.in/api"/>
<parameter name="env" value="staging"/>
  --> TestNG passes these to your test classes via:
  @Parameters({"baseUrl", "env"})
  @BeforeClass
  public void setup(String baseUrl, String env) {
      RestAssured.baseURI = baseUrl;
      System.out.println("Running on environment: " + env);
  }
  Makes your framework environment-agnostic.

When given like in testng.xml file like below
<listener class-name="utils.TestRailListener"/>
 --> Automatically hooks into test lifecycle events.
 Syncs results with TestRail without touching test code.

 <preserve-order="true">
Ensures that within a <test> block, classes and methods run in the order defined.
For critical tests or dependent APIs, this avoids failures due to wrong sequence.

You can define User API tests, Product API tests, Payment API tests, etc in respective test blocks.
Each block can run in parallel or sequentially.

Sample tesng.xml file:
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="API Automation Suite" verbose="1" parallel="tests" thread-count="2">

    <!-- Global Parameters (for different environments) -->
    <parameter name="baseUrl" value="https://reqres.in/api"/>
    <parameter name="env" value="staging"/>

    <!-- Attach Listeners -->
    <listeners>
        <listener class-name="utils.TestRailListener"/>
    </listeners>

    <!-- Test Block 1: User APIs -->
    <test name="User API Tests" preserve-order="true">
        <classes>
            <class name="tests.UserTests"/>
        </classes>
    </test>

    <!-- Test Block 2: Product APIs -->
    <test name="Product API Tests" preserve-order="true">
        <classes>
            <class name="tests.ProductTests"/>
        </classes>
    </test>

</suite>


We can map Rest Assured + TestNG framework to TestRail so the API test results automatically show up in TestRail reports
by using TestNG listener( by creating a class which implements ITestListener, ISuiteListener interfaces).



---------------------------------------------
validate response schema in Rest Assured?
Schema validation ensures that your API response matches the expected structure, not just the values.
For example:
Fields exist and are of the correct type (string, int, array, etc.)
No unexpected fields appear
The overall JSON structure matches the specification (usually a .json schema file)

for this
1.we need to add the JSON Schema Validator module to your pom.xml:
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>json-schema-validator</artifactId>
    <version>5.4.0</version>
    <scope>test</scope>
</dependency>

2.Create a file userSchema.json under resources folder.
3.Validate the Schema in Rest Assured Test.
   ex:  given()
                   .when()
                   .get("/users/2")
                   .then()
                   .assertThat()
                   .statusCode(200)
                   .body(JsonSchemaValidator.matchesJsonSchemaInClasspath("schemas/userSchema.json"));
           }
       }

  Explanation:
  .matchesJsonSchemaInClasspath("schemas/userSchema.json")
  ‚Üí Loads the schema from src/test/resources/schemas/ folder.
  .body() ‚Üí Validates the entire response structure against the schema.

We can combine Schema + Field validation like below.
.then()
    .statusCode(200)
    .body(JsonSchemaValidator.matchesJsonSchemaInClasspath("schemas/userSchema.json"))
    .body("data.first_name", equalTo("Janet"));
-------------------------------------------------------------
Can we validate XML schemas?
Yes, using matchesXsdInClasspath() for XML responses.

-------------------------------------------------------------

What is an SSL Certificate?
SSL (Secure Sockets Layer) is a protocol that encrypts data between a client (like a browser or your test script)
and a server (like https://myapp.com).
An SSL certificate is a digital certificate that:
Authenticates the server ‚Äì proves that the server is who it says it is.
Encrypts data ‚Äì ensures that information (like passwords, API tokens) is secure in transit.
Prevents tampering ‚Äì helps avoid ‚Äúman-in-the-middle‚Äù attacks.

When you visit a site with HTTPS, your browser checks the SSL certificate to make sure it‚Äôs valid and issued
by a trusted authority (CA).

How SSL Works in Simple Terms:
Browser or client ‚Üí ‚ÄúHello, I want to connect securely‚Äù.
Server ‚Üí Sends its SSL certificate.
Browser/client ‚Üí Checks: Is the certificate valid (not expired)?, Was it issued by a trusted Certificate Authority(CA)?,
Does the domain match the certificate?.
If valid ‚Üí a secure encrypted connection is established.
If invalid ‚Üí you get errors like SSLHandshakeException or ‚ÄúUntrusted Certificate‚Äù.

Why Rest Assured complains about SSL.
Java (and Rest Assured) checks the SSL certificate by default.
If the certificate is self-signed, expired, or from an unknown CA, you get:
javax.net.ssl.SSLHandshakeException
That‚Äôs why we sometimes use .relaxedHTTPSValidation() in testing environments.


How do you handle SSL certificate issues in Rest Assured?
Common Ways to Handle SSL in Rest Assured :
1.Use relaxedHTTPSValidation()
ex: given()
        .relaxedHTTPSValidation()   // Ignores SSL certificate validation
        .when()
        .get("https://self-signed.badssl.com/")
        .then()
        .statusCode(200);


2.Globally disable SSL validation.
@BeforeClass
    public void setup() {
        RestAssured.useRelaxedHTTPSValidation();
        RestAssured.baseURI = "https://staging.myapp.com";
    }
    Now all your test classes will skip SSL verification automatically.



 3. Use a custom keystore/truststore (if required).
 If your company provides internal certificates you must trust, use this approach:
 given()
     .keyStore("/path/to/keystore.jks", "password")
     .trustStore("/path/to/truststore.jks", "password")
 .when()
     .get("https://staging.myapp.com/api")
 .then()
     .statusCode(200);
     üëâ This is the secure enterprise way ‚Äî use this when you must explicitly trust certain certificates.

In Rest Assured, if the API endpoint uses a self-signed or invalid SSL certificate (common in QA environments),
we can handle it by calling .relaxedHTTPSValidation() or setting RestAssured.useRelaxedHTTPSValidation() globally.
For production-level security, it‚Äôs better to configure a proper truststore or keystore rather than skipping
SSL verification entirely.
-----------------------------------------------------------------

HTTP Status Codes:
| Category          | Range   | Meaning                                                              |
| ----------------- | ------- | -------------------------------------------------------------------- |
| **Informational** | 100‚Äì199 | Request received, continuing process                                 |
| **Success**       | 200‚Äì299 | Request was successfully received, understood, and accepted          |
| **Redirection**   | 300‚Äì399 | Further action required to complete the request                      |
| **Client Error**  | 400‚Äì499 | The request has an error (bad syntax, unauthorized, forbidden, etc.) |
| **Server Error**  | 500‚Äì599 | Server failed to fulfill a valid request                             |

| Code    | Name                       | Meaning / When to Use                                        |
| ------- | -------------------------- | ------------------------------------------------------------ |
| **200** | OK                         | Request succeeded; response body contains the result         |
| **201** | Created                    | Resource successfully created (POST request)                 |
| **204** | No Content                 | Request succeeded but no data returned (DELETE or empty GET) |
| **301** | Moved Permanently          | URL has changed permanently; client should redirect          |
| **302** | Found / Temporary Redirect | URL temporarily moved; client may redirect                   |
| **400** | Bad Request                | Client sent invalid syntax or data                           |
| **401** | Unauthorized               | Authentication failed or missing                             |
| **403** | Forbidden                  | Authenticated but doesn‚Äôt have permission                    |
| **404** | Not Found                  | Resource doesn‚Äôt exist                                       |
| **405** | Method Not Allowed         | HTTP method (GET/POST) not supported on this endpoint        |
| **500** | Internal Server Error      | Server encountered an error while processing request         |
| **502** | Bad Gateway                | Server received invalid response from upstream server        |
| **503** | Service Unavailable        | Server is down for maintenance or overloaded                 |

-----------------------------------------------------------------

| Method | Purpose                 | Idempotent                                                                               | Request Body | Example Use            |
| ------ | ----------------------- | ---------------------------------------------------------------------------------------- | ------------ | ---------------------- |
| GET    | Retrieve data           | ‚úÖ **Yes ‚Äî calling multiple times has the same effect; no changes on server**             | No           | Get user details       |
| POST   | Create new resource     | ‚ùå **No ‚Äî calling multiple times creates multiple resources**                             | Yes          | Add a new post         |
| PUT    | Update entire resource  | ‚úÖ **Yes ‚Äî calling multiple times replaces the resource with the same state**             | Yes          | Replace user info      |
| PATCH  | Update partial resource | ‚úÖ **Yes ‚Äî calling multiple times results in the same final state**                       | Yes          | Update user email only |
| DELETE | Remove resource         | ‚úÖ **Yes ‚Äî calling multiple times deletes the resource; subsequent calls may return 404** | Usually No   | Delete a post          |

------------------------------------------------------------------

| Feature                 | Path Parameter                   | Query Parameter                        |
| ----------------------- | -------------------------------- | -------------------------------------- |
| **Position in URL**     | Part of path (`/users/{id}`)     | After `?` (`/users?id=2`)              |
| **Purpose**             | Identify a **specific resource** | Filter, sort, search, or optional data |
| **Required**            | Usually yes                      | Usually optional                       |
| **Rest Assured syntax** | `.pathParam("id", 2)`            | `.queryParam("userId", 1)`             |
| **Example URL**         | `/users/2`                       | `/users?name=Leanne`                   |

------------------------------------------------------------------

What {id} Means in the code?
Curly braces {} indicate a path parameter in the URL. It‚Äôs a placeholder that will be replaced dynamically with a
value at runtime. Rest Assured allows you to map it using .pathParam("name", value).
------------------------------------------------------------------



Write a test case to assert that a specific exception is thrown in TestNG.
import org.testng.annotations.Test;
public class AgeValidatorTestNG {

    @Test(expectedExceptions = IllegalArgumentException.class)
    public void testValidateAgeThrowsException() {
        AgeValidator validator = new AgeValidator();
        validator.validateAge(15);  // should throw exception
    }
}
Test passes only if IllegalArgumentException is thrown.


